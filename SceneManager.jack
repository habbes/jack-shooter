class SceneManager {
    field Tank hero;
    field Array bullets;
    field int bulletCount, maxBullets;

    constructor SceneManager new () {
        let bulletCount = 0;
        let maxBullets = 20;
        let bullets = Array.new(maxBullets);
        return this;
    }

    method Tank getHero () {
        return hero;
    }

    method void setHero (Tank h) {
        let hero = h;
        return;
    }

    method void addBullet (Bullet b) {
        var int i;
        var boolean added;
        var Bullet temp;
        let added = false;
        if( bulletCount < maxBullets) {
            let i = 0;
            // find empty slot in array and add bullet there
            while ((i < maxBullets) & (~added)) {
                let temp = bullets[i];
                if (temp = null) {
                    let bullets[i] = b;
                    let added = true;
                    let bulletCount = bulletCount + 1;
                }
                let i = i + 1;
            }
        }

        if (~added) {
            // dispose of bullet since it won't be tracked by scene
            do b.dispose();
        }
        return;
    }

    method void refresh () {
        var int i;
        var Bullet b;
        do hero.onRefresh();
        if (hero.shouldUpdate()) {
            do Viewport.clearArea(hero.getLastX(), hero.getLastY(), hero.getWidth(), hero.getHeight());
            do hero.draw();
            do hero.markClean();
        }
        
        let i = 0;
        while (i < bulletCount) {
            let b = bullets[i];
            if (~(b = null)) {
                do b.onRefresh();
                if (b.shouldUpdate()) {
                    do Viewport.clearArea(b.getLastX(), b.getLastY(), b.getWidth(), b.getHeight());
                    if (isOutOfBounds(b)) {
                        do b.dispose();
                        // recycle bullet space to create room for more bullets on the scene
                        let bullets[i] = null;
                        let bulletCount = bulletCount - 1;
                    }
                    else {
                        do b.draw();
                        do b.markClean();
                    }
                }
                
            }
            let i = i + 1;
        }
        return;
    }

    method boolean isOutOfBounds(Bullet b) {
        return Viewport.isAreaOutOfBounds(b.getX(), b.getY(), b.getWidth(), b.getHeight());
    }

    method void dispose () {
        do Memory.deAlloc(this);
        return;
    }
}