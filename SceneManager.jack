class SceneManager {
    field Tank hero;
    field Array bullets;
    field int bulletCount, maxBullets;
    field Array enemies;
    field int enemyCount, maxEnemies;
    field int currentKey;
    field int nextObjectId;

    constructor SceneManager new () {
        let bulletCount = 0;
        let maxBullets = 20;
        let bullets = Array.new(maxBullets);
        let enemyCount = 0;
        let maxEnemies = 20;
        let enemies = Array.new(maxEnemies);
        let nextObjectId = 1;
        return this;
    }

    method int generateId () {
        var int temp;
        let temp = nextObjectId;
        let nextObjectId = nextObjectId + 1;
        return temp;
    }

    method int getCurrentKey () {
        return currentKey;
    }
    method Tank getHero () {
        return hero;
    }

    method void setHero (Tank h) {
        var SceneObject so;
        let hero = h;
        let so = h.getSceneObject();
        do so.setId(generateId());
        do so.setCoord(Viewport.getCenterX(), Viewport.getCenterY());
        return;
    }

    method void addBullet (Bullet b) {
        var int i;
        var boolean added;
        var Bullet temp;
        var SceneObject so;
        let added = false;
        if( bulletCount < maxBullets) {
            let i = 0;
            // find empty slot in array and add bullet there
            while ((i < maxBullets) & (~added)) {
                let temp = bullets[i];
                if (temp = null) {
                    let bullets[i] = b;
                    let so = b.getSceneObject();
                    do so.setId(generateId());
                    let added = true;
                    let bulletCount = bulletCount + 1;
                }
                let i = i + 1;
            }
        }

        if (~added) {
            // dispose of bullet since it won't be tracked by scene
            do b.dispose();
        }
        return;
    }

    method void spawnEnemy () {
        var int i;
        var Enemy temp, e;
        var SceneObject so;
        var boolean added;
        let added = false;
        // only add enemy if there's room
        if (enemyCount < maxEnemies) {
            let i = 0;
            // find first available slot
            while ((i < maxEnemies) & (~added)) {
                let temp = enemies[i];
                if (temp = null) {
                    let e = Enemy.new(50, 50);
                    let so = e.getSceneObject();
                    do so.setId(generateId());
                    do e.draw(); // force first draw since objects are created clean
                    let enemies[i] = e;
                    let enemyCount = enemyCount + 1;
                    let added = true;
                }
                let i = i + 1;
            }
        }
        return;
    }

    method void keyPressed(int key) {
        let currentKey = key;
        return;
    }

    method void refresh () {
        do refreshHero();
        do refreshEnemies();
        do refreshBullets();

        return;
    }

    method void refreshHero () {
        var SceneObject so;
        do hero.onRefresh(this);
        let so = hero.getSceneObject();
        if (so.shouldUpdate()) {
            do clearObjectArea(so);
            do hero.draw();
            do so.markClean();
        }
        return;
    }

    method void refreshEnemies () {
        var int i;
        var Enemy e;
        var SceneObject so;
        let i = 0;
        while (i < maxBullets) {
            let e = enemies[i];
            if (~(e = null)) {
                
                do e.onRefresh(this);
                let so = e.getSceneObject();
                if (so.shouldUpdate()) {
                    do clearObjectArea(so);
                    do e.draw();
                    do so.markClean();
                }
                if (e.isDead()) {
                    do e.dispose();
                    let enemies[i] = null;
                }
            }
            let i = i + 1;
        }
        return;
    }

    method void refreshBullets () {
        var int i;
        var Bullet b;
        var SceneObject so;
        let i = 0;
        while (i < maxBullets) {
            let b = bullets[i];
            if (~(b = null)) {
                do b.onRefresh(this);
                let so = b.getSceneObject();
                if (so.shouldUpdate()) {
                    do clearObjectArea(so);
                    if (isOutOfBounds(so) | checkBulletHits(b)) {
                        do b.dispose();
                        // recycle bullet space to create room for more bullets on the scene
                        let bullets[i] = null;
                        let bulletCount = bulletCount - 1;
                    }
                    else {
                        do b.draw();
                        do so.markClean();
                    }
                }
                
            }
            let i = i + 1;
        }
        return;
    }

    method void clearObjectArea (SceneObject so) {
        do Viewport.clearArea(so.getLastX(), so.getLastY(), so.getWidth(), so.getHeight());
        return;
    }

    method boolean isOutOfBounds(SceneObject o) {
        return Viewport.isAreaOutOfBounds(o.getX(), o.getY(), o.getWidth(), o.getHeight());
    }

    method boolean checkHeroCollisions () {
        var Enemy e;
        var SceneObject hso, eso;
        var int i;

        // let hso = hero.getSceneObject();
        // while (i < maxEnemies) {
        //     let e = enemies[i];
        //     if (~(e = null)) {
        //         let eso = e.getSceneObject();
        //         if (hso.checkCollision(eso)) {
        //             return true;
        //         }
        //     }
        //     let i = i + 1;
        // }

        return false;
    }

    method boolean checkBulletHits (Bullet b) {
        var SceneObject bso, eso;
        var Enemy e;
        var int i;
        let bso = b.getSceneObject();

        let i = 0;
        while (i < maxEnemies) {
            let e = enemies[i];
            if (~(e = null)) {
                let eso = e.getSceneObject();
                if (bso.checkCollision(eso)) {
                    do e.die();
                    return true;
                }
            }
            let i = i + 1;
        }
        return false;
    }

    method Enemy collidesWithEnemy (SceneObject cur) {
        var Enemy e;
        var SceneObject other;
        var int i;

        let i = 0;
        while (i < maxEnemies) {
            let e = enemies[i];
            if (~(e = null)) {
                let other = e.getSceneObject();
                if (cur.checkCollision(other)) {
                    return e;
                }
            }
            let i = i + 1;
        }
        return null;
    }

    method Bullet collidesWithBullet (SceneObject o) {
        var Bullet b;
        var SceneObject bo;
        var int i;
        let i = 0;
        while (i < maxBullets) {
            let b = bullets[i];
            if (~(b = null)) {
                let bo = b.getSceneObject();
                if (o.checkCollision(bo)) {
                    return b;
                }
            }
            let i = i + 1;
        }
        return null;
    }

    method boolean isAreaFree (int x, int y, int w, int h) {
        var SceneObject temp, so;
        var Enemy e;
        var Bullet b;
        var int i;
        let temp = SceneObject.new(x, y, w, h, 0, 0);

        let so = hero.getSceneObject();
        if (temp.checkCollision(so)) {
            return false;
        }

        let e = collidesWithEnemy(temp);
        if (~(e = null)) {
            return false;
        }

        let b = collidesWithBullet(temp);
        if (~(b = null)) {
            return false;
        }

        do temp.dispose();
        return true;

    }

    method void dispose () {
        var int i;
        var Bullet b;
        var Enemy e;

        // dispose of hero
        do hero.dispose();

        // dispose of enemies
        let i = 0;
        while (i < maxEnemies) {
            let e = enemies[i];
            if (~(e = null)) {
                do e.dispose();
            }
            let i = i + 1;
        }
        do enemies.dispose();

        // dipose of bullets
        let i = 0;
        while (i < maxBullets) {
            let b = bullets[i];
            if (~(b = null)) {
                do b.dispose();
            }
            let i = i + 1;
        }
        do bullets.dispose();


        do Memory.deAlloc(this);
        return;
    }
}